---
// Performance Monitor Component - Only loads in development
const isDev = import.meta.env.DEV
---

{isDev && (
  <script>
    // Core Web Vitals Monitoring
    function observeWebVitals() {
      // Import web-vitals library dinamically if available
      const logVital = (metric) => {
        console.log(`[Performance] ${metric.name}:`, metric.value, metric.unit);
        
        // Send to analytics (implement your analytics here)
        // gtag('event', metric.name, {
        //   value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value),
        //   event_category: 'Web Vitals',
        //   event_label: metric.id,
        //   non_interaction: true,
        // });
      };

      // Manual CLS observer
      let clsValue = 0;
      let clsEntries = [];

      const observer = new PerformanceObserver((entryList) => {
        for (const entry of entryList.getEntries()) {
          if (!entry.hadRecentInput) {
            const firstSessionEntry = clsEntries[0];
            const lastSessionEntry = clsEntries[clsEntries.length - 1];

            if (!firstSessionEntry || entry.startTime - lastSessionEntry.startTime < 1000) {
              clsEntries.push(entry);
              clsValue += entry.value;
            }
          }
        }
      });

      observer.observe({type: 'layout-shift', buffered: true});

      // Log performance timing
      window.addEventListener('load', () => {
        const navigation = performance.getEntriesByType('navigation')[0];
        if (navigation) {
          console.log('[Performance] Navigation Timing:', {
            'DNS Lookup': navigation.domainLookupEnd - navigation.domainLookupStart,
            'TCP Connection': navigation.connectEnd - navigation.connectStart,
            'Request': navigation.responseStart - navigation.requestStart,
            'Response': navigation.responseEnd - navigation.responseStart,
            'DOM Processing': navigation.domContentLoadedEventEnd - navigation.responseEnd,
            'Load Complete': navigation.loadEventEnd - navigation.loadEventStart,
            'Total Load Time': navigation.loadEventEnd - navigation.navigationStart
          });
        }

        // Log CLS
        logVital({
          name: 'CLS',
          value: clsValue,
          unit: '',
          id: 'cls-' + Date.now()
        });
      });

      // FCP (First Contentful Paint) observer
      const fcpObserver = new PerformanceObserver((entryList) => {
        for (const entry of entryList.getEntries()) {
          if (entry.name === 'first-contentful-paint') {
            logVital({
              name: 'FCP',
              value: entry.startTime,
              unit: 'ms',
              id: 'fcp-' + Date.now()
            });
          }
        }
      });

      fcpObserver.observe({type: 'paint', buffered: true});

      // LCP (Largest Contentful Paint) observer
      const lcpObserver = new PerformanceObserver((entryList) => {
        const entries = entryList.getEntries();
        const lastEntry = entries[entries.length - 1];
        
        logVital({
          name: 'LCP',
          value: lastEntry.startTime,
          unit: 'ms',
          id: 'lcp-' + Date.now()
        });
      });

      lcpObserver.observe({type: 'largest-contentful-paint', buffered: true});

      // FID (First Input Delay) observer
      const fidObserver = new PerformanceObserver((entryList) => {
        for (const entry of entryList.getEntries()) {
          const delay = entry.processingStart - entry.startTime;
          logVital({
            name: 'FID',
            value: delay,
            unit: 'ms',
            id: 'fid-' + Date.now()
          });
        }
      });

      fidObserver.observe({type: 'first-input', buffered: true});
    }

    // Resource loading monitoring
    function monitorResources() {
      const resourceObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.duration > 1000) { // Log slow resources (>1s)
            console.warn(`[Performance] Slow resource: ${entry.name} (${Math.round(entry.duration)}ms)`);
          }
        }
      });

      resourceObserver.observe({entryTypes: ['resource']});
    }

    // Memory usage monitoring (Chrome only)
    function monitorMemory() {
      if ('memory' in performance) {
        setInterval(() => {
          const memory = performance.memory;
          console.log('[Performance] Memory Usage:', {
            'Used JS Heap': Math.round(memory.usedJSHeapSize / 1048576) + ' MB',
            'Total JS Heap': Math.round(memory.totalJSHeapSize / 1048576) + ' MB',
            'JS Heap Limit': Math.round(memory.jsHeapSizeLimit / 1048576) + ' MB'
          });
        }, 30000); // Log every 30 seconds
      }
    }

    // Initialize monitoring
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        observeWebVitals();
        monitorResources();
        monitorMemory();
      });
    } else {
      observeWebVitals();
      monitorResources();
      monitorMemory();
    }

    console.log('[Performance] ðŸš€ Performance monitoring active in development mode');
  </script>
)}
